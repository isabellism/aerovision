<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>ORBITA - Controle Jedi 5.1</title>
    <script src="https://aframe.io/releases/1.4.0/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>

    <style>
        body { margin: 0; padding: 0; overflow: hidden; background: #000; display: flex; width: 100vw; height: 100vh; }
        .viewport { flex: 1; height: 100vh; position: relative; overflow: hidden; border-right: 1px solid #333; }
        video.webcam { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; z-index: 1; pointer-events: none; }
        a-scene { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 2; }
        #start-btn { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); padding: 25px 40px; background: #00AAFF; color: white; border: none; border-radius: 12px; z-index: 10000; font-weight: bold; font-size: 1.2rem; }
    </style>
</head>
<body>

    <button id="start-btn">INICIAR (PERMITIR SENSORES)</button>

    <div class="viewport">
        <video class="webcam" autoplay playsinline muted></video>
        <a-scene embedded vr-mode-ui="enabled: false">
            <a-entity id="cam-l" camera position="-0.035 1.6 0" look-controls="enabled: true; magicWindowTrackingEnabled: true">
                <a-text class="action-txt" value="MAO LIVRE" position="0 0.6 -2" align="center" width="2.5" color="#FFF"></a-text>
                <a-sphere class="cursor" radius="0.03" color="white" position="10 10 -1.5"></a-sphere>
            </a-entity>

            <a-entity position="0 1 -2.5">
                <a-box position="-0.8 -0.5 0" scale="0.2 0.2 0.2" color="white" opacity="0.3"></a-box>
                <a-sphere position="0 -0.5 0" radius="0.12" color="white" opacity="0.3"></a-sphere>
                <a-cone position="0.8 -0.5 0" radius-bottom="0.15" height="0.25" color="white" opacity="0.3"></a-cone>

                <a-box class="obj-cubo" position="-0.8 0.5 0" scale="0.2 0.2 0.2" color="#FF4B4B"></a-box>
                <a-sphere class="obj-esfera" position="0 0.5 0" radius="0.12" color="#00AAFF"></a-sphere>
                <a-cone class="obj-piramide" position="0.8 0.5 0" radius-bottom="0.15" height="0.25" color="#32CD32"></a-cone>
                <a-grid material="opacity: 0.15; color: #555" position="0 -0.6 0"></a-grid>
            </a-entity>
            <a-light type="directional" position="1 2 1" intensity="1.5"></a-light>
            <a-light type="ambient" intensity="0.6"></a-light>
        </a-scene>
    </div>

    <div class="viewport" style="border-right: none;">
        <video class="webcam" autoplay playsinline muted></video>
        <a-scene embedded vr-mode-ui="enabled: false">
            <a-entity id="cam-r" camera position="0.035 1.6 0" look-controls="enabled: true; magicWindowTrackingEnabled: true">
                <a-text class="action-txt" value="MAO LIVRE" position="0 0.6 -2" align="center" width="2.5" color="#FFF"></a-text>
                <a-sphere class="cursor" radius="0.03" color="white" position="10 10 -1.5"></a-sphere>
            </a-entity>

            <a-entity position="0 1 -2.5">
                <a-box position="-0.8 -0.5 0" scale="0.2 0.2 0.2" color="white" opacity="0.3"></a-box>
                <a-sphere position="0 -0.5 0" radius="0.12" color="white" opacity="0.3"></a-sphere>
                <a-cone position="0.8 -0.5 0" radius-bottom="0.15" height="0.25" color="white" opacity="0.3"></a-cone>

                <a-box class="obj-cubo" position="-0.8 0.5 0" scale="0.2 0.2 0.2" color="#FF4B4B"></a-box>
                <a-sphere class="obj-esfera" position="0 0.5 0" radius="0.12" color="#00AAFF"></a-sphere>
                <a-cone class="obj-piramide" position="0.8 0.5 0" radius-bottom="0.15" height="0.25" color="#32CD32"></a-cone>
                <a-grid material="opacity: 0.15; color: #555" position="0 -0.6 0"></a-grid>
            </a-entity>
            <a-light type="directional" position="1 2 1" intensity="1.5"></a-light>
            <a-light type="ambient" intensity="0.6"></a-light>
        </a-scene>
    </div>

    <script>
        const hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
        hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.6, minTrackingConfidence: 0.6 });

        let pieces = {
            'cubo': { x: -0.8, y: 0.5, rZ: 0, scale: 0.2, targetX: -0.8 },
            'esfera': { x: 0, y: 0.5, rZ: 0, scale: 0.12, targetX: 0 },
            'piramide': { x: 0.8, y: 0.5, rZ: 0, scale: 1, targetX: 0.8 }
        };

        let activePiece = null;
        let actionState = "LIVRE";
        
        // Variáveis para o Duplo Clique (Reset)
        let lastPinchTime = 0;
        let wasPinching = false;

        // Variáveis para estabilizar rotação e zoom
        let initialHandAngle = 0;
        let initialObjRotation = 0;
        let initialHandY = 0;
        let initialObjScale = 1;

        hands.onResults((res) => {
            if (!res.multiHandLandmarks || res.multiHandLandmarks.length === 0) {
                document.querySelectorAll('.cursor').forEach(c => c.setAttribute('position', `10 10 -1.5`));
                updateHUD("MAO LIVRE", "#FFF");
                return;
            }

            const h = res.multiHandLandmarks[0];
            const x = (h[8].x - 0.5) * 4; 
            const y = (0.5 - h[8].y) * 3;
            
            document.querySelectorAll('.cursor').forEach(c => c.setAttribute('position', `${x} ${y} -1.5`));

            const distThumbIndex = Math.hypot(h[4].x - h[8].x, h[4].y - h[8].y);
            const distThumbMiddle = Math.hypot(h[4].x - h[12].x, h[4].y - h[12].y);

            // DETECÇÃO DOS GESTOS
            const isPinch = distThumbIndex < 0.08 && distThumbMiddle > 0.1; // Só 2 dedos
            const isThreeFingers = distThumbIndex < 0.08 && distThumbMiddle < 0.08; // 3 dedos juntos

            // LÓGICA DE DUPLO CLIQUE PARA RESETAR (Fora de peças)
            let currentTime = Date.now();
            if (isPinch && !wasPinching && !activePiece) {
                if (currentTime - lastPinchTime < 500) {
                    resetMesa();
                    updateHUD("SISTEMA REINICIADO", "#FF4B4B");
                }
                lastPinchTime = currentTime;
            }
            wasPinching = isPinch;

            // SELEÇÃO DE PEÇA PRÓXIMA
            if (actionState === "LIVRE") {
                let closest = null; let minDist = 0.6;
                for (const key in pieces) {
                    const d = Math.hypot(x - pieces[key].x, y - pieces[key].y);
                    if (d < minDist) { minDist = d; closest = key; }
                }
                activePiece = closest;
            }

            if (!activePiece) return;
            const p = pieces[activePiece];

            // EXECUÇÃO DAS AÇÕES
            if (isThreeFingers) {
                // TRÊS DEDOS: ROTAÇÃO E ZOOM SIMULTÂNEOS
                if (actionState !== "MANIPULANDO") {
                    actionState = "MANIPULANDO";
                    // Captura o ângulo da mão (inclinação do pulso)
                    initialHandAngle = Math.atan2(h[17].y - h[5].y, h[17].x - h[5].x);
                    initialObjRotation = p.rZ;
                    // Captura altura da mão para Zoom
                    initialHandY = h[0].y; 
                    initialObjScale = p.scale;
                }

                updateHUD(`MANIPULANDO: ${activePiece.toUpperCase()}`, "#FFD700");

                // Calcula Rotação (girar o pulso)
                let currentHandAngle = Math.atan2(h[17].y - h[5].y, h[17].x - h[5].x);
                let angleDiff = currentHandAngle - initialHandAngle;
                p.rZ = initialObjRotation - (angleDiff * (180 / Math.PI) * 1.5); // 1.5 é sensibilidade

                // Calcula Zoom (mover a mão para cima/baixo)
                let yDiff = h[0].y - initialHandY;
                let scaleMultiplier = 1 + (yDiff * -3); // -3 inverte o eixo e dá sensibilidade
                if (scaleMultiplier < 0.3) scaleMultiplier = 0.3; // limite mínimo
                if (scaleMultiplier > 3.0) scaleMultiplier = 3.0; // limite máximo
                
                p.scale = initialObjScale * scaleMultiplier;
                updateVisuals(activePiece);

            } else if (isPinch) {
                // DOIS DEDOS: MOVER
                actionState = "MOVENDO";
                updateHUD(`MOVENDO: ${activePiece.toUpperCase()}`, "#00AAFF");
                p.x = x; p.y = y;
                updateVisuals(activePiece);

            } else {
                // SOLTOU TUDO
                if (actionState === "MOVENDO") {
                    const dTarget = Math.hypot(p.x - p.targetX, p.y - (-0.5));
                    if (dTarget < 0.4) {
                        p.x = p.targetX; p.y = -0.5; p.rZ = 0; p.scale = getBaseScale(activePiece);
                        updateVisuals(activePiece);
                        updateHUD("ENCAIXE PERFEITO", "#32CD32");
                    }
                }
                actionState = "LIVRE";
                if(!isPinch && !isThreeFingers) updateHUD("MAO LIVRE", "#FFF");
            }
        });

        function resetMesa() {
            pieces['cubo'] = { x: -0.8, y: 0.5, rZ: 0, scale: 0.2, targetX: -0.8 };
            pieces['esfera'] = { x: 0, y: 0.5, rZ: 0, scale: 0.12, targetX: 0 };
            pieces['piramide'] = { x: 0.8, y: 0.5, rZ: 0, scale: 1, targetX: 0.8 };
            ['cubo', 'esfera', 'piramide'].forEach(k => updateVisuals(k));
        }

        function getBaseScale(key) {
            if(key === 'cubo') return 0.2;
            if(key === 'esfera') return 0.12;
            return 1;
        }

        function updateVisuals(key) {
            const p = pieces[key];
            document.querySelectorAll(`.obj-${key}`).forEach(el => {
                el.setAttribute('position', `${p.x} ${p.y} 0`);
                // Aplica rotação (girando no próprio eixo)
                el.setAttribute('rotation', `0 0 ${p.rZ}`);
                
                // Aplica Zoom (escala)
                if(key === 'cubo') el.setAttribute('scale', `${p.scale} ${p.scale} ${p.scale}`);
                if(key === 'esfera') el.setAttribute('radius', `${p.scale}`);
                if(key === 'piramide') {
                    el.setAttribute('radius-bottom', `${0.15 * p.scale}`);
                    el.setAttribute('height', `${0.25 * p.scale}`);
                }
            });
        }

        function updateHUD(txt, color) {
            document.querySelectorAll('.action-txt').forEach(el => {
                el.setAttribute('value', txt);
                el.setAttribute('color', color);
            });
        }

        document.getElementById('start-btn').addEventListener('click', async () => {
            // SOLICITAÇÃO CRÍTICA PARA O GIROSCÓPIO DA APPLE (Para fixar os objetos no mundo)
            if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                try {
                    const permission = await DeviceOrientationEvent.requestPermission();
                    if (permission !== 'granted') alert("Sem giroscópio, as peças vão seguir seu rosto.");
                } catch (e) { console.error(e); }
            }

            const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" } });
            document.querySelectorAll('.webcam').forEach(v => { v.srcObject = stream; v.play(); });
            document.getElementById('start-btn').style.display = 'none';
            const vid = document.querySelectorAll('.webcam')[0];
            function run() { if (vid.readyState >= 2) hands.send({image: vid}); requestAnimationFrame(run); }
            run();
        });
    </script>
</body>
</html>
